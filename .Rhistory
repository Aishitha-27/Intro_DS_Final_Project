fancyRpartPlot(regression_tree)
residuals_tree <- test_data1$total_sales_revenue - predict(regression_tree, test_data1)
MAE_tree <- mean(abs(residuals_tree))
RMSE_tree <- sqrt(mean(residuals_tree^2))
SS_total_tree <- sum((test_data1$total_sales_revenue - mean(test_data1$total_sales_revenue))^2)
SS_residual_tree <- sum(residuals_tree^2)
R_squared_tree <- 1 - (SS_residual_tree / SS_total_tree)
n <- nrow(test_data1)  # number of d
p <- length(coef(regression_tree))  # number of predictors
Adjusted_R_squared_tree <- 1 - ((1 - R_squared_tree) * (n - 1)) / (n - p - 1)
cat("MAE (Tree):", MAE_tree, "\n")
cat("RMSE (Tree):", RMSE_tree, "\n")
cat("R-squared (Tree):", R_squared_tree, "\n")
cat("Adjusted R-squared (Tree):", Adjusted_R_squared_tree, "\n")
# Load caret library
library(caret)
# Predictions already made using your model
predictions <- predict(classification_tree, test_data, type = "class")
# Load caret library
library(caret)
# Predictions already made using your model
predictions <- predict(classification_tree, test_data, type = "class")
set.seed(1)
kyphosisfit <- rpart(Kyphosis ~ Age + Number + Start, data=kyphosis, method="class", control = list(maxdepth = 4) )
# kyphosisfit <- rpart(Kyphosis ~ Age + Number + Start, data=kyphosis, method="class", control = {rpart.control list} )
# rpart.control(maxdepth = 30, minsplit = 20, minbucket = round(minsplit/3), cp = 0.01, maxcompete = 4, maxsurrogate = 5, usesurrogate = 2, xval = 10, surrogatestyle = 0, ...)
summary(kyphosisfit) # detailed summary of splits
# plot tree
plot(kyphosisfit, uniform=TRUE, main="Classification Tree for Kyphosis")
text(kyphosisfit, use.n=TRUE, all=TRUE, cex=.8)
library(caret)
cm = confusionMatrix( predict(classification_tree, type = "class"), reference = customer_segment[, "customer_segment"] )
library(caret)
cm = confusionMatrix( predict(classification_tree, type = "class"), reference = train_data[, "customer_segment"] )
predictions <- predict(classification_tree, test_data, type = "class")
predictions <- predict(classification_tree, test_data, type = "class")
predictions <- predict(classification_tree, test_data, type = "class")
confusion_matrix <- table(Actual = test_data$customer_segment, Predicted = test_data$predicted_segment)
print(confusion_matrix)
library(ezids)
library(ggplot2)
library(dplyr)
library(tidyverse)
library(outliers)
library(reshape2)
library(lubridate)
library(scales)
library(rpart)
library(rpart.plot)
library(caret)
library(magrittr)
library(Metrics)
library(rattle)
library(corrplot)
library(pROC)
data=read.csv("C:\\Users\\Cashapona\\Downloads\\online_sales_dataset.csv")
head(data, 5)
colSums(is.na(data_clean))
kd2_outliers <- function(column) {
density <- density(column, na.rm = TRUE)
threshold <- 0.01  # Define a threshold for low-density regions
outlier_indices <- which(density(column)$y < threshold)
return(length(outlier_indices))  # Return the count of outliers
}
outliers_quantity <- kd2_outliers(data_reduced$Quantity)
outliers_unit_price <- kd2_outliers(data_reduced$UnitPrice)
outliers_discount <- kd2_outliers(data_reduced$Discount)
cat("Outliers in Quantity:", outliers_quantity, "\n")
cat("Outliers in Unit Price:", outliers_unit_price, "\n")
cat("Outliers in Discount:", outliers_discount, "\n")
remove_kd2_outliers <- function(df, column) {
density <- density(df[[column]], na.rm = TRUE)
threshold <- 0.01  # Define a threshold for low-density regions
outlier_indices <- which(density$y < threshold)
if (length(outlier_indices) > 0) {
df <- df[-outlier_indices, ]
}
return(df)
}
cleaned_data <- data_reduced %>%
remove_kd2_outliers("Quantity") %>%
remove_kd2_outliers("UnitPrice") %>%
remove_kd2_outliers("Discount")
sales_data <- cleaned_data %>%
group_by(StockCode, OrderPriority, CustomerID) %>%
summarise(
avg_discount = mean(Discount, na.rm = TRUE),
total_sales_revenue = sum(UnitPrice * Quantity, na.rm = TRUE),
total_quantity_sold = sum(Quantity, na.rm = TRUE),
.groups = "drop"
)
customer_data <- cleaned_data %>%
select(CustomerID, Country, PaymentMethod) %>%
distinct(CustomerID, .keep_all = TRUE)
sales_data <- sales_data %>%
left_join(customer_data, by = "CustomerID")
lm_sales_model <- lm(
total_sales_revenue ~ avg_discount + OrderPriority + PaymentMethod + total_quantity_sold, data = train_data1)
summary(lm_sales_model)
lm_sales_model$coefficients
fitted_values <- lm_sales_model$fitted.values
residuals <- train_data1$total_sales_revenue - fitted_values
MAE <- mean(abs(residuals))
RMSE <- sqrt(mean(residuals^2))
SS_total <- sum((train_data1$total_sales_revenue - mean(train_data1$total_sales_revenue))^2)
SS_residual <- sum(residuals^2)
R_squared <- 1 - (SS_residual / SS_total)
n <- nrow(train_data1)
p <- length(coef(lm_sales_model)) - 1
Adjusted_R_squared <- 1 - ((1 - R_squared) * (n - 1)) / (n - p - 1)
cat("MAE:", MAE, "\n")
cat("RMSE:", RMSE, "\n")
cat("R-squared:", R_squared, "\n")
cat("Adjusted R-squared:", Adjusted_R_squared, "\n")
regression_tree <- rpart(
total_sales_revenue ~ avg_discount + OrderPriority + Country + PaymentMethod + total_quantity_sold,data = train_data,method="anova")
customer_data <- cleaned_data %>%
group_by(CustomerID) %>%
summarize(
purchase_frequency = n_distinct(InvoiceNo),
total_quantity = sum(Quantity, na.rm = TRUE),
total_spend = sum(UnitPrice * Quantity, na.rm = TRUE),
avg_discount = mean(Discount, na.rm = TRUE),
preferred_payment = as.character(names(sort(table(PaymentMethod), decreasing = TRUE)[1])),
preferred_category = as.character(names(sort(table(Category), decreasing = TRUE)[1]))
)
spend_summary <- summary(customer_data$total_spend)
low_threshold <- spend_summary["1st Qu."]
high_threshold <- spend_summary["3rd Qu."]
customer_data <- customer_data %>%
mutate(
customer_segment = case_when(
total_spend < low_threshold ~ "Low",
total_spend >= low_threshold & total_spend < high_threshold ~ "Medium",
total_spend >= high_threshold ~ "High"
)
)
customer_data$preferred_payment <-  as.factor(customer_data$preferred_payment)
customer_data$preferred_category <- as.factor(customer_data$preferred_category)
customer_data$preferred_payment <- as.numeric(customer_data$preferred_payment)
customer_data$preferred_category <- as.numeric(customer_data$preferred_category)
set.seed(123)
train_indices <- sample(1:nrow(customer_data), 0.7 * nrow(customer_data))
train_data <- customer_data[train_indices, ]
test_data <- customer_data[-train_indices, ]
classification_tree <- rpart(
customer_segment ~ purchase_frequency + total_quantity + avg_discount + preferred_payment + preferred_category,
data = train_data,
method = "class"
)
summary(classification_tree)
predictions <- predict(classification_tree, test_data, type = "class")
test_data$predicted_segment <- predictions
confusion_matrix <- confusionMatrix(
data = as.factor(test_data$predicted_segment),    # Predicted values
reference = as.factor(test_data$customer_segment) # Actual values
)
# Print the confusion matrix
print(confusion_matrix)
predictions <- predict(classification_tree, test_data, type = "class")
# Add predictions to the test data
test_data$predicted_segment <- predictions
# Create a confusion matrix using the caret package
confusion_matrix <- confusionMatrix(
data = as.factor(test_data$predicted_segment),    # Predicted values
reference = as.factor(test_data$customer_segment) # Actual values
)
# Print the confusion matrix
print(confusion_matrix
predictions <- predict(classification_tree, test_data, type = "class")
test_data$predicted_segment <- predictions
confusion_matrix <- confusionMatrix(
data = as.factor(test_data$predicted_segment),
reference = as.factor(test_data$customer_segment))
print(confusion_matrix)
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
cat("Accuracy:", confusion_matrix$accuracy, "\n")
cat("Accuracy:", confusion_matrix$overall["Accuracy"], "\n")
logistic_model$coefficients
predicted_probabilities <- predict(logistic_model, test_data, type = "response")
predicted_probabilities <- predict(logistic_model, test_data, type = "response")
customer_data <- cleaned_data %>%
group_by(CustomerID) %>%
summarize(
purchase_frequency = n_distinct(InvoiceNo),
total_quantity = sum(Quantity, na.rm = TRUE),
total_spend = sum(UnitPrice * Quantity, na.rm = TRUE),
avg_discount = mean(Discount, na.rm = TRUE),
preferred_payment = as.character(names(sort(table(PaymentMethod), decreasing = TRUE)[1])),
preferred_category = as.character(names(sort(table(Category), decreasing = TRUE)[1]))
)
spend_summary <- summary(customer_data$total_spend)
low_threshold <- spend_summary["1st Qu."]
high_threshold <- spend_summary["3rd Qu."]
customer_data <- customer_data %>%
mutate(
customer_segment = case_when(
total_spend < low_threshold ~ "Low",
total_spend >= low_threshold & total_spend < high_threshold ~ "Medium",
total_spend >= high_threshold ~ "High"
)
)
customer_data$preferred_payment <-  as.factor(customer_data$preferred_payment)
customer_data$preferred_category <- as.factor(customer_data$preferred_category)
customer_data$preferred_payment <- as.numeric(customer_data$preferred_payment)
customer_data$preferred_category <- as.numeric(customer_data$preferred_category)
set.seed(123)
train_indices <- sample(1:nrow(customer_data), 0.7 * nrow(customer_data))
train_data <- customer_data[train_indices, ]
test_data <- customer_data[-train_indices, ]
classification_tree <- rpart(
customer_segment ~ purchase_frequency + total_quantity + avg_discount + preferred_payment + preferred_category,
data = train_data,
method = "class"
)
summary(classification_tree)
fancyRpartPlot(classification_tree)
predictions <- predict(classification_tree, test_data, type = "class")
test_data$predicted_segment <- predictions
confusion_matrix <- table(Actual = test_data$customer_segment, Predicted = test_data$predicted_segment)
print(confusion_matrix)
confusion_matrix <- confusionMatrix(
data = as.factor(test_data$predicted_segment),    # Predicted values
reference = as.factor(test_data$customer_segment) # Actual values
)
# Print the confusion matrix
print(confusion_matrix)
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
predicted_probs <- predict(classification_tree, test_data, type = "prob")
actual <- ifelse(test_data$customer_segment == "High", 1, 0)
predicted <- predicted_probs[, "High"]
thresholds <- seq(0, 1, by = 0.01)
tpr <- c()
fpr <- c()
for (threshold in thresholds) {
predicted_class <- ifelse(predicted >= threshold, 1, 0)
tp <- sum(predicted_class == 1 & actual == 1)
fp <- sum(predicted_class == 1 & actual == 0)
fn <- sum(predicted_class == 0 & actual == 1)
tn <- sum(predicted_class == 0 & actual == 0)
tpr <- c(tpr, tp / (tp + fn))
fpr <- c(fpr, fp / (fp + tn))
}
plot(fpr, tpr, type = "l", col = "blue", lwd = 2, xlab = "False Positive Rate", ylab = "True Positive Rate",
main = "ROC Curve")
abline(a = 0, b = 1, col = "red", lty = 2)
sortedindices = order(fpr)
fpr = fpr[sortedindices]
tpr = tpr[sortedindices]
auc = sum((fpr[-1] - fpr[-length(fpr)]) * (tpr[-1] + tpr[-length(tpr)]) / 2)
cat("AUC:",auc, "\n")
logistic_data <- cleaned_data %>%
mutate(
SalesChannel = ifelse(SalesChannel == "Online", 1, 0)
) %>%
select(
SalesChannel, CustomerID, Quantity, UnitPrice, Discount, OrderPriority, Country, PaymentMethod
)
set.seed(123)
train_indices <- sample(1:nrow(logistic_data), 0.7 * nrow(logistic_data))
train_data <- logistic_data[train_indices, ]
test_data <- logistic_data[-train_indices, ]
logistic_model <- glm(
SalesChannel ~ Quantity + UnitPrice + Discount + OrderPriority + Country + PaymentMethod,
data = train_data,
family = "binomial"
)
summary(logistic_model)
logistic_model$coefficients
predicted_probabilities <- predict(logistic_model, test_data, type = "response")
test_data$predicted_channel <- ifelse(predicted_probabilities > 0.5, 1, 0)
predicted_probabilities <- predict(logistic_model, test_data, type = "response")
# Convert probabilities to binary predictions based on a threshold (e.g., 0.5)
test_data$predicted_channel <- ifelse(predicted_probabilities > 0.5, 1, 0)
# Create confusion matrix using caret
confusion_matrix <- confusionMatrix(
data = as.factor(test_data$predicted_channel),     # Predicted values
reference = as.factor(test_data$SalesChannel)      # Actual values
# Load necessary libraries
library(caret)
# Predict probabilities on the test data
predicted_probabilities <- predict(logistic_model, newdata = test_data, type = "response")
# Convert probabilities to binary predictions (threshold = 0.5)
predicted_class <- ifelse(predicted_probabilities > 0.5, 1, 0)
# Add predictions to the test data for reference
test_data$predicted_sales_channel <- predicted_class
# Create a confusion matrix using caret
confusion_matrix <- confusionMatrix(
data = as.factor(test_data$predicted_sales_channel),   # Predicted values
reference = as.factor(test_data$SalesChannel)         # Actual values
)
# Print the confusion matrix
print(confusion_matrix)
predicted_probs_log <- predict(logistic_model, test_data, type = "response")
actual_log <- test_data$SalesChannel
roc_log <- roc(actual_log, predicted_probs_log)
plot(roc_log, col = "green", lwd = 2, main = "ROC Curve: Logistic Regression")
abline(a = 0, b = 1, col = "red", lty = 2)
cat("AUC for Logistic Regression:", auc(roc_log), "\n")
predicted_probs_log <- predict(logistic_model, test_data, type = "response")
actual_log <- test_data$SalesChannel
roc_log <- roc(actual_log, predicted_probs_log)
plot(roc_log, col = "green", lwd = 2, main = "ROC Curve: Logistic Regression")
abline(a = 0, b = 1, col = "red", lty = 2)
cat("AUC for Logistic Regression:", auc(roc_log), "\n")
predicted_probs = predict(logistic_model, test_data, type = "response")
roc_curve= roc(test_data$SalesChannel, predicted_probabilities)
plot(roc_curve, col = "blue", lwd = 2, main = "ROC Curve")
abline(a = 0, b = 1, col = "red", lty = 2)
auc_value = auc(roc_curve)
cat("AUC:", auc_value, "\n")
predicted_probabilities <- predict(logistic_model, newdata = test_data, type = "response")
predicted_class <- ifelse(predicted_probabilities > 0.5, 1, 0)
test_data$predicted_sales_channel <- predicted_class
confusion_matrix <- confusionMatrix(
data = as.factor(test_data$predicted_sales_channel),
reference = as.factor(test_data$SalesChannel))
print(confusion_matrix)
predicted_probs = predict(logistic_model, test_data, type = "response")
roc_curve= roc(test_data$SalesChannel, predicted_probabilities)
plot(roc_curve, col = "blue", lwd = 2, main = "ROC Curve")
abline(a = 0, b = 1, col = "red", lty = 2)
auc_value = auc(roc_curve)
cat("AUC:", auc_value, "\n")
predicted_probabilities <- predict(logistic_model, newdata = test_data, type = "response")
predicted_class <- ifelse(predicted_probabilities > 0.5, 1, 0)
test_data$predicted_sales_channel <- predicted_class
confusion_matrix2 <- confusionMatrix(
data = as.factor(test_data$predicted_sales_channel),
reference = as.factor(test_data$SalesChannel))
print(confusion_matrix2)
accuracy <- sum(diag(confusion_matrix2)) / sum(confusion_matrix2)
accuracy <- confusion_matrix2$overall["Accuracy"]
print(accuracy)
accuracy <- confusion_matrix2$overall["Accuracy"]
cat("Accuracy:", accuracy, "\n")
sales_data <- cleaned_data %>%
group_by(StockCode, OrderPriority, CustomerID) %>%
summarise(
avg_discount = mean(Discount, na.rm = TRUE),
total_sales_revenue = sum(UnitPrice * Quantity, na.rm = TRUE),
total_quantity_sold = sum(Quantity, na.rm = TRUE),
.groups = "drop"
)
customer_data <- cleaned_data %>%
select(CustomerID, Country, PaymentMethod) %>%
distinct(CustomerID, .keep_all = TRUE)
sales_data <- sales_data %>%
left_join(customer_data, by = "CustomerID")
cor_matrix <- cor(sales_data %>% select(avg_discount, total_sales_revenue, total_quantity_sold))
corrplot(
cor_matrix,
method = "color",
type = "upper",
addCoef.col = "black",
tl.col = "black",
col = colorRampPalette(c("red", "white", "purple"))(200))
set.seed(123)
train_indices1 <- sample(1:nrow(sales_data), 0.7 * nrow(sales_data))
train_data1 <- sales_data[train_indices1, ]
test_data1 <- sales_data[-train_indices1, ]
lm_sales_model <- lm(
total_sales_revenue ~ avg_discount + OrderPriority + PaymentMethod + total_quantity_sold,
data = train_data1)
summary(lm_sales_model)
lm_sales_model$coefficients
fitted_values <- lm_sales_model$fitted.values
residuals <- train_data1$total_sales_revenue - fitted_values
MAE <- mean(abs(residuals))
RMSE <- sqrt(mean(residuals^2))
SS_total <- sum((train_data1$total_sales_revenue - mean(train_data1$total_sales_revenue))^2)
SS_residual <- sum(residuals^2)
R_squared <- 1 - (SS_residual / SS_total)
n <- nrow(train_data1)
p <- length(coef(lm_sales_model)) - 1
Adjusted_R_squared <- 1 - ((1 - R_squared) * (n - 1)) / (n - p - 1)
cat("MAE:", MAE, "\n")
cat("RMSE:", RMSE, "\n")
cat("R-squared:", R_squared, "\n")
cat("Adjusted R-squared:", Adjusted_R_squared, "\n")
regression_tree <- rpart(
total_sales_revenue ~ avg_discount + OrderPriority + PaymentMethod + total_quantity_sold,data = train_data1,method="anova")
summary(regression_tree)
fancyRpartPlot(regression_tree)
residuals_tree <- test_data1$total_sales_revenue - predict(regression_tree, test_data1)
MAE_tree <- mean(abs(residuals_tree))
RMSE_tree <- sqrt(mean(residuals_tree^2))
SS_total_tree <- sum((test_data1$total_sales_revenue - mean(test_data1$total_sales_revenue))^2)
SS_residual_tree <- sum(residuals_tree^2)
R_squared_tree <- 1 - (SS_residual_tree / SS_total_tree)
n <- nrow(test_data1)  # number of data points
p <- length(coef(regression_tree))  # number of predictors
Adjusted_R_squared_tree <- 1 - ((1 - R_squared_tree) * (n - 1)) / (n - p - 1)
cat("MAE (Tree):", MAE_tree, "\n")
cat("RMSE (Tree):", RMSE_tree, "\n")
cat("R-squared (Tree):", R_squared_tree, "\n")
cat("Adjusted R-squared (Tree):", Adjusted_R_squared_tree, "\n")
customer_data <- cleaned_data %>%
group_by(CustomerID) %>%
summarize(
purchase_frequency = n_distinct(InvoiceNo),
total_quantity = sum(Quantity, na.rm = TRUE),
total_spend = sum(UnitPrice * Quantity, na.rm = TRUE),
avg_discount = mean(Discount, na.rm = TRUE),
preferred_payment = as.character(names(sort(table(PaymentMethod), decreasing = TRUE)[1])),
preferred_category = as.character(names(sort(table(Category), decreasing = TRUE)[1]))
)
spend_summary <- summary(customer_data$total_spend)
low_threshold <- spend_summary["1st Qu."]
high_threshold <- spend_summary["3rd Qu."]
customer_data <- customer_data %>%
mutate(
customer_segment = case_when(
total_spend < low_threshold ~ "Low",
total_spend >= low_threshold & total_spend < high_threshold ~ "Medium",
total_spend >= high_threshold ~ "High"
)
)
customer_data$preferred_payment <-  as.factor(customer_data$preferred_payment)
customer_data$preferred_category <- as.factor(customer_data$preferred_category)
customer_data$preferred_payment <- as.numeric(customer_data$preferred_payment)
customer_data$preferred_category <- as.numeric(customer_data$preferred_category)
cor_matrix <- cor(customer_data %>%
select(purchase_frequency, total_quantity, avg_discount, preferred_payment, preferred_category),
use = "complete.obs")
corrplot(
cor_matrix,
method = "color",
type = "upper",
addCoef.col = "black",
tl.col = "black",
col = colorRampPalette(c("red", "white", "purple"))(200),
mar = c(0, 0, 1, 0))
set.seed(123)
train_indices <- sample(1:nrow(customer_data), 0.7 * nrow(customer_data))
train_data <- customer_data[train_indices, ]
test_data <- customer_data[-train_indices, ]
classification_tree <- rpart(
customer_segment ~ purchase_frequency + total_quantity + avg_discount + preferred_payment + preferred_category,
data = train_data,
method = "class"
)
summary(classification_tree)
fancyRpartPlot(classification_tree)
predictions <- predict(classification_tree, test_data, type = "class")
test_data$predicted_segment <- predictions
confusion_matrix <- confusionMatrix(
data = as.factor(test_data$predicted_segment),
reference = as.factor(test_data$customer_segment))
print(confusion_matrix)
cat("Accuracy:", confusion_matrix$overall["Accuracy"], "\n")
predicted_probs <- predict(classification_tree, test_data, type = "prob")
actual <- ifelse(test_data$customer_segment == "High", 1, 0)
predicted <- predicted_probs[, "High"]
thresholds <- seq(0, 1, by = 0.01)
tpr <- c()
fpr <- c()
for (threshold in thresholds) {
predicted_class <- ifelse(predicted >= threshold, 1, 0)
tp <- sum(predicted_class == 1 & actual == 1)
fp <- sum(predicted_class == 1 & actual == 0)
fn <- sum(predicted_class == 0 & actual == 1)
tn <- sum(predicted_class == 0 & actual == 0)
tpr <- c(tpr, tp / (tp + fn))
fpr <- c(fpr, fp / (fp + tn))
}
plot(fpr, tpr, type = "l", col = "blue", lwd = 2, xlab = "False Positive Rate", ylab = "True Positive Rate",
main = "ROC Curve")
abline(a = 0, b = 1, col = "red", lty = 2)
sortedindices = order(fpr)
fpr = fpr[sortedindices]
tpr = tpr[sortedindices]
auc = sum((fpr[-1] - fpr[-length(fpr)]) * (tpr[-1] + tpr[-length(tpr)]) / 2)
cat("AUC:",auc, "\n")
logistic_data <- cleaned_data %>%
mutate(
SalesChannel = ifelse(SalesChannel == "Online", 1, 0)
) %>%
select(
SalesChannel, CustomerID, Quantity, UnitPrice, Discount, OrderPriority, Country, PaymentMethod)
logistic_data <- cleaned_data %>%
mutate(
SalesChannel = ifelse(SalesChannel == "Online", 1, 0)
) %>%
select(
SalesChannel, CustomerID, Quantity, UnitPrice, Discount, OrderPriority, PaymentMethod)
set.seed(123)
train_indices <- sample(1:nrow(logistic_data), 0.7 * nrow(logistic_data))
train_data <- logistic_data[train_indices, ]
test_data <- logistic_data[-train_indices, ]
logistic_model <- glm(
SalesChannel ~ Quantity + UnitPrice + Discount + OrderPriority + PaymentMethod,
data = train_data,
family = "binomial"
)
summary(logistic_model)
predicted_probabilities <- predict(logistic_model, newdata = test_data, type = "response")
predicted_class <- ifelse(predicted_probabilities > 0.5, 1, 0)
test_data$predicted_sales_channel <- predicted_class
confusion_matrix2 <- confusionMatrix(
data = as.factor(test_data$predicted_sales_channel),
reference = as.factor(test_data$SalesChannel))
print(confusion_matrix2)
logistic_model$coefficients
predicted_probabilities <- predict(logistic_model, newdata = test_data, type = "response")
predicted_class <- ifelse(predicted_probabilities > 0.5, 1, 0)
test_data$predicted_sales_channel <- predicted_class
confusion_matrix2 <- confusionMatrix(
data = as.factor(test_data$predicted_sales_channel),
reference = as.factor(test_data$SalesChannel))
print(confusion_matrix2)
