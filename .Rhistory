library(ezids)
library(ggplot2)
library(dplyr)
library(tidyverse)
library(outliers)
library(reshape2)
library(lubridate)
library(scales)
library(rpart)
library(rpart.plot)
library(caret)
library(magrittr)
library(Metrics)
library(rattle)
library(corrplot)
library(pROC)
data=read.csv("online_sales_dataset.csv")
head(data, 5)
data_clean<- na.omit(data)
set.seed(123)
data_reduced <- data_clean %>% sample_n(10000)
remove_kd2_outliers <- function(df, column) {
density <- density(df[[column]], na.rm = TRUE)
threshold <- 0.01  # Define a threshold for low-density regions
outlier_indices <- which(density$y < threshold)
if (length(outlier_indices) > 0) {
df <- df[-outlier_indices, ]
}
return(df)
}
cleaned_data <- data_reduced %>%
remove_kd2_outliers("Quantity") %>%
remove_kd2_outliers("UnitPrice") %>%
remove_kd2_outliers("Discount")
kd2_outliers <- function(column) {
density <- density(column, na.rm = TRUE)
threshold <- 0.01  # Define a threshold for low-density regions
outlier_indices <- which(density(column)$y < threshold)
return(length(outlier_indices))  # Return the count of outliers
}
outliers_quantity <- kd2_outliers(data_reduced$Quantity)
outliers_unit_price <- kd2_outliers(data_reduced$UnitPrice)
outliers_discount <- kd2_outliers(data_reduced$Discount)
cat("Outliers in Quantity:", outliers_quantity, "\n")
cat("Outliers in Unit Price:", outliers_unit_price, "\n")
cat("Outliers in Discount:", outliers_discount, "\n")
remove_kd2_outliers <- function(df, column) {
density <- density(df[[column]], na.rm = TRUE)
threshold <- 0.01  # Define a threshold for low-density regions
outlier_indices <- which(density$y < threshold)
if (length(outlier_indices) > 0) {
df <- df[-outlier_indices, ]
}
return(df)
}
cleaned_data <- data_reduced %>%
remove_kd2_outliers("Quantity") %>%
remove_kd2_outliers("UnitPrice") %>%
remove_kd2_outliers("Discount")
cleaned_data$InvoiceDate <- as.Date(cleaned_data$InvoiceDate, format = "%d-%m-%Y")
cleaned_data$Description = as.factor(cleaned_data$Description)
cleaned_data$StockCode = as.factor(cleaned_data$StockCode)
cleaned_data$Country = as.factor(cleaned_data$Country)
cleaned_data$PaymentMethod = as.factor(cleaned_data$PaymentMethod)
cleaned_data$Category = as.factor(cleaned_data$Category)
cleaned_data$ReturnStatus = as.factor(cleaned_data$ReturnStatus)
cleaned_data$SalesChannel = as.factor(cleaned_data$SalesChannel)
cleaned_data$ShipmentProvider = as.factor(cleaned_data$ShipmentProvider)
cleaned_data$OrderPriority = as.factor(cleaned_data$OrderPriority)
cleaned_data$WarehouseLocation = as.factor(cleaned_data$WarehouseLocation)
sales_data <- cleaned_data %>%
group_by(StockCode, OrderPriority, CustomerID) %>%
summarise(
avg_discount = mean(Discount, na.rm = TRUE),
total_sales_revenue = sum(UnitPrice * Quantity, na.rm = TRUE),
total_quantity_sold = sum(Quantity, na.rm = TRUE),
.groups = "drop"
)
customer_data <- cleaned_data %>%
select(CustomerID, Country, PaymentMethod) %>%
distinct(CustomerID, .keep_all = TRUE)
sales_data <- sales_data %>%
left_join(customer_data, by = "CustomerID")
set.seed(123)
train_indices <- sample(1:nrow(sales_data), 0.7 * nrow(sales_data))
train_data <- sales_data[train_indices, ]
test_data <- sales_data[-train_indices, ]
cor_matrix <- cor(train_data %>% select(avg_discount, total_sales_revenue, total_quantity_sold))
corrplot(
cor_matrix,
method = "color",
type = "upper",
addCoef.col = "black",
tl.col = "black",
col = colorRampPalette(c("red", "white", "purple"))(200))
lm_sales_model <- lm(
total_sales_revenue ~ avg_discount + OrderPriority + Country + PaymentMethod + total_quantity_sold,
data = train_data)
summary(lm_sales_model)
predictions <- predict(lm_sales_model, test_data)
test_data$predicted_sales <- predictions
comparison <- data.frame(Actual = test_data$total_sales_revenue,
Predicted = test_data$predicted_sales)
head(comparison, 10)
residuals <- test_data$total_sales_revenue - predictions
MAE <- mean(abs(residuals))
RMSE <- sqrt(mean(residuals^2))
SS_total <- sum((test_data$total_sales_revenue - mean(test_data$total_sales_revenue))^2)
SS_residual <- sum(residuals^2)
R_squared <- 1 - (SS_residual / SS_total)
cat("MAE:", MAE, "\n")
cat("RMSE:", RMSE, "\n")
cat("R-squared:", R_squared, "\n")
regression_tree <- rpart(
total_sales_revenue ~ avg_discount + OrderPriority + Country + PaymentMethod + total_quantity_sold,data = train_data,method="anova")
summary(regression_tree)
importance_values <- as.data.frame(regression_tree$variable.importance)
var_importance <- data.frame(
Variable = rownames(importance_values),
Overall = as.numeric(importance_values$`regression_tree$variable.importance`)
)
rownames(var_importance) <- NULL
ggplot(var_importance, aes(x = reorder(Variable, Overall), y = Overall)) +
geom_bar(stat = "identity", fill = "skyblue") +
coord_flip() +
labs(title = "Feature Importance",x = "Features",
y = "Importance")
fancyRpartPlot(regression_tree)
tree_predictions <- predict(regression_tree, test_data)
test_data$predicted_sales_tree <- tree_predictions
comparison_tree <- data.frame(Actual = test_data$total_sales_revenue,
Predicted = test_data$predicted_sales_tree)
head(comparison_tree, 10)
mae_value <- mae(comparison_tree$Actual, comparison_tree$Predicted)
rmse_value <- rmse(comparison_tree$Actual, comparison_tree$Predicted)
mape_value <- mape(comparison_tree$Actual, comparison_tree$Predicted)
cat("MAE:", mae_value, "\nRMSE:", rmse_value, "\nMAPE:", mape_value)
customer_data <- cleaned_data %>%
group_by(CustomerID) %>%
summarize(
purchase_frequency = n_distinct(InvoiceNo),
total_quantity = sum(Quantity, na.rm = TRUE),
total_spend = sum(UnitPrice * Quantity, na.rm = TRUE),
avg_discount = mean(Discount, na.rm = TRUE),
preferred_payment = as.character(names(sort(table(PaymentMethod), decreasing = TRUE)[1])),
preferred_category = as.character(names(sort(table(Category), decreasing = TRUE)[1]))
)
spend_summary <- summary(customer_data$total_spend)
low_threshold <- spend_summary["1st Qu."]
high_threshold <- spend_summary["3rd Qu."]
customer_data <- customer_data %>%
mutate(
customer_segment = case_when(
total_spend < low_threshold ~ "Low",
total_spend >= low_threshold & total_spend < high_threshold ~ "Medium",
total_spend >= high_threshold ~ "High"
)
)
customer_data$preferred_payment <-  as.factor(customer_data$preferred_payment)
customer_data$preferred_category <- as.factor(customer_data$preferred_category)
customer_data$preferred_payment <- as.numeric(customer_data$preferred_payment)
customer_data$preferred_category <- as.numeric(customer_data$preferred_category)
cor_matrix <- cor(customer_data %>%
select(purchase_frequency, total_quantity, avg_discount, preferred_payment, preferred_category),
use = "complete.obs")
corrplot(
cor_matrix,
method = "color",
type = "upper",
addCoef.col = "black",
tl.col = "black",
col = colorRampPalette(c("red", "white", "purple"))(200),
mar = c(0, 0, 1, 0))
set.seed(123)
train_indices <- sample(1:nrow(customer_data), 0.7 * nrow(customer_data))
train_data <- customer_data[train_indices, ]
test_data <- customer_data[-train_indices, ]
classification_tree <- rpart(
customer_segment ~ purchase_frequency + total_quantity + avg_discount + preferred_payment + preferred_category,
data = train_data,
method = "class"
)
summary(classification_tree)
fancyRpartPlot(classification_tree)
predictions <- predict(classification_tree, test_data, type = "class")
test_data$predicted_segment <- predictions
confusion_matrix <- table(Actual = test_data$customer_segment, Predicted = test_data$predicted_segment)
print(confusion_matrix)
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
cat("Accuracy:", accuracy, "\n")
predicted_probs <- predict(classification_tree, test_data, type = "prob")
actual <- ifelse(test_data$customer_segment == "High", 1, 0)
predicted <- predicted_probs[, "High"]
thresholds <- seq(0, 1, by = 0.01)
tpr <- c()
fpr <- c()
for (threshold in thresholds) {
predicted_class <- ifelse(predicted >= threshold, 1, 0)
tp <- sum(predicted_class == 1 & actual == 1)
fp <- sum(predicted_class == 1 & actual == 0)
fn <- sum(predicted_class == 0 & actual == 1)
tn <- sum(predicted_class == 0 & actual == 0)
tpr <- c(tpr, tp / (tp + fn))
fpr <- c(fpr, fp / (fp + tn))
}
plot(fpr, tpr, type = "l", col = "blue", lwd = 2, xlab = "False Positive Rate", ylab = "True Positive Rate",
main = "ROC Curve")
abline(a = 0, b = 1, col = "red", lty = 2)
auc <- sum((fpr[-1] - fpr[-length(fpr)]) * (tpr[-1] + tpr[-length(tpr)]) / 2)
cat("AUC:", auc, "\n")
logistic_data <- cleaned_data %>%
mutate(
SalesChannel = ifelse(SalesChannel == "Online", 1, 0)
) %>%
select(
SalesChannel, CustomerID, Quantity, UnitPrice, Discount, OrderPriority, Country, PaymentMethod
)
set.seed(123)
train_indices <- sample(1:nrow(), 0.7 * nrow(logistic_data))
set.seed(123)
train_indices <- sample(1:nrow(logistic_data), 0.7 * nrow(logistic_data))
train_data <- logistic_data[train_indices, ]
test_data <- logistic_data[-train_indices, ]
logistic_model <- glm(
SalesChannel ~ Quantity + UnitPrice + Discount + OrderPriority + Country + PaymentMethod,
data = train_data,
family = "binomial"
)
summary(logistic_model)
predicted_probabilities <- predict(logistic_model, test_data, type = "response")
test_data$predicted_channel <- ifelse(predicted_probabilities > 0.5, 1, 0)
confusion_matrix <- table(Actual = test_data$SalesChannel, Predicted = test_data$predicted_channel)
print(confusion_matrix)
performance <- confusionMatrix(factor(test_data$predicted_channel), factor(test_data$SalesChannel))
accuracy <- performance$overall["Accuracy"]
print(accuracy)
thresholds <- seq(0, 1, by = 0.01)
# Initialize vectors to store TPR and FPR values for each threshold
tpr <- numeric(length(thresholds))
fpr <- numeric(length(thresholds))
# Loop over each threshold to calculate TPR and FPR
for (i in 1:length(thresholds)) {
threshold <- thresholds[i]
# Predicted labels: 1 if predicted probability is greater than the threshold, else 0
predicted_labels <- ifelse(predicted_probabilities > threshold, 1, 0)
# Create confusion matrix
confusion <- table(Predicted = predicted_labels, Actual = actual_values)
# Ensure the confusion matrix has all the required values (TP, FP, FN, TN)
tp <- confusion["1", "1"]  # True Positive
tn <- confusion["0", "0"]  # True Negative
fp <- confusion["0", "1"]  # False Positive
fn <- confusion["1", "0"]  # False Negative
# If any value is missing, set it to 0
tp <- ifelse(is.na(tp), 0, tp)
tn <- ifelse(is.na(tn), 0, tn)
fp <- ifelse(is.na(fp), 0, fp)
fn <- ifelse(is.na(fn), 0, fn)
# Calculate True Positive Rate (TPR) = TP / (TP + FN), handling zero division
tpr[i] <- ifelse((tp + fn) != 0, tp / (tp + fn), 0)
# Calculate False Positive Rate (FPR) = FP / (FP + TN), handling zero division
fpr[i] <- ifelse((fp + tn) != 0, fp / (fp + tn), 0)
}
