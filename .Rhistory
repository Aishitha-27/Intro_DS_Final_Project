theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(hjust = 0.5, face = "bold")
)
product_preferences <- cleaned_data %>%
group_by(Description, Country) %>%
summarise(TotalSales = sum(UnitPrice * Quantity, na.rm = TRUE), .groups = "drop")
ggplot(product_preferences, aes(x = Description, y = TotalSales, fill = Country)) +
geom_bar(stat = "identity", position = "stack") +
labs(
title = "Product Preferences by Customer Type",
x = "Product",
y = "Total Sales",
fill = "Customer Type") +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(hjust = 0.5, face = "bold"))
unique(cleaned_data$PaymentMethod)
payment_segregation <- table(cleaned_data$PaymentMethod, cleaned_data$Category)
chisq_test <- chisq.test(payment_segregation)
print(chisq_test)
t_test <- t.test(Quantity ~ Discount > 0.1, data = cleaned_data)
print(t_test)
anova <- aov(ShippingCost ~ ShipmentProvider, data = cleaned_data)
summary(anova)
t_test2 <- t.test(Quantity ~ SalesChannel, data = cleaned_data)
print(t_test2)
return_category <- table(cleaned_data$ReturnStatus, cleaned_data$Category)
chisq_test2 <- chisq.test(return_category)
print(chisq_test2)
sales_data <- cleaned_data %>%
group_by(StockCode, OrderPriority, CustomerID) %>%
summarise(
avg_discount = mean(Discount, na.rm = TRUE),
total_sales_revenue = sum(UnitPrice * Quantity, na.rm = TRUE),
total_quantity_sold = sum(Quantity, na.rm = TRUE),
.groups = "drop"
)
customer_data <- cleaned_data %>%
select(CustomerID, Country, PaymentMethod) %>%
distinct(CustomerID, .keep_all = TRUE)
sales_data <- sales_data %>%
left_join(customer_data, by = "CustomerID")
cor_matrix <- cor(sales_data %>% select(avg_discount, total_sales_revenue, total_quantity_sold))
corrplot(
cor_matrix,
method = "color",
type = "upper",
addCoef.col = "black",
tl.col = "black",
col = colorRampPalette(c("red", "white", "purple"))(200))
set.seed(123)
train_indices1 <- sample(1:nrow(sales_data), 0.7 * nrow(sales_data))
train_data1 <- sales_data[train_indices1, ]
test_data1 <- sales_data[-train_indices1, ]
lm_sales_model <- lm(
total_sales_revenue ~ avg_discount + OrderPriority + Country + PaymentMethod + total_quantity_sold,
data = train_data1)
summary(lm_sales_model)
fitted_values <- lm_sales_model$fitted.values
residuals <- train_data1$total_sales_revenue - fitted_values
MAE <- mean(abs(residuals))
RMSE <- sqrt(mean(residuals^2))
SS_total <- sum((train_data1$total_sales_revenue - mean(train_data1$total_sales_revenue))^2)
SS_residual <- sum(residuals^2)
R_squared <- 1 - (SS_residual / SS_total)
n <- nrow(train_data1)
p <- length(coef(lm_sales_model)) - 1
Adjusted_R_squared <- 1 - ((1 - R_squared) * (n - 1)) / (n - p - 1)
cat("MAE:", MAE, "\n")
cat("RMSE:", RMSE, "\n")
cat("R-squared:", R_squared, "\n")
cat("Adjusted R-squared:", Adjusted_R_squared, "\n")
regression_tree <- rpart(
total_sales_revenue ~ avg_discount + OrderPriority + Country + PaymentMethod + total_quantity_sold,data = train_data1,method="anova")
summary(regression_tree)
importance_values <- as.data.frame(regression_tree$variable.importance)
var_importance <- data.frame(
Variable = rownames(importance_values),
Overall = as.numeric(importance_values$`regression_tree$variable.importance`)
)
rownames(var_importance) <- NULL
ggplot(var_importance, aes(x = reorder(Variable, Overall), y = Overall)) +
geom_bar(stat = "identity", fill = "skyblue") +
coord_flip() +
labs(title = "Feature Importance",x = "Features",
y = "Importance")
fancyRpartPlot(regression_tree)
residuals_tree <- test_data1$total_sales_revenue - predict(regression_tree, test_data1)
MAE_tree <- mean(abs(residuals_tree))
RMSE_tree <- sqrt(mean(residuals_tree^2))
SS_total_tree <- sum((test_data1$total_sales_revenue - mean(test_data1$total_sales_revenue))^2)
SS_residual_tree <- sum(residuals_tree^2)
R_squared_tree <- 1 - (SS_residual_tree / SS_total_tree)
n <- nrow(test_data1)  # number of data points
p <- length(coef(regression_tree))  # number of predictors
Adjusted_R_squared_tree <- 1 - ((1 - R_squared_tree) * (n - 1)) / (n - p - 1)
cat("MAE (Tree):", MAE_tree, "\n")
cat("RMSE (Tree):", RMSE_tree, "\n")
cat("R-squared (Tree):", R_squared_tree, "\n")
cat("Adjusted R-squared (Tree):", Adjusted_R_squared_tree, "\n")
customer_data <- cleaned_data %>%
group_by(CustomerID) %>%
summarize(
purchase_frequency = n_distinct(InvoiceNo),
total_quantity = sum(Quantity, na.rm = TRUE),
total_spend = sum(UnitPrice * Quantity, na.rm = TRUE),
avg_discount = mean(Discount, na.rm = TRUE),
preferred_payment = as.character(names(sort(table(PaymentMethod), decreasing = TRUE)[1])),
preferred_category = as.character(names(sort(table(Category), decreasing = TRUE)[1]))
)
spend_summary <- summary(customer_data$total_spend)
low_threshold <- spend_summary["1st Qu."]
high_threshold <- spend_summary["3rd Qu."]
customer_data <- customer_data %>%
mutate(
customer_segment = case_when(
total_spend < low_threshold ~ "Low",
total_spend >= low_threshold & total_spend < high_threshold ~ "Medium",
total_spend >= high_threshold ~ "High"
)
)
customer_data$preferred_payment <-  as.factor(customer_data$preferred_payment)
customer_data$preferred_category <- as.factor(customer_data$preferred_category)
customer_data$preferred_payment <- as.numeric(customer_data$preferred_payment)
customer_data$preferred_category <- as.numeric(customer_data$preferred_category)
cor_matrix <- cor(customer_data %>%
select(purchase_frequency, total_quantity, avg_discount, preferred_payment, preferred_category),
use = "complete.obs")
corrplot(
cor_matrix,
method = "color",
type = "upper",
addCoef.col = "black",
tl.col = "black",
col = colorRampPalette(c("red", "white", "purple"))(200),
mar = c(0, 0, 1, 0))
set.seed(123)
train_indices <- sample(1:nrow(customer_data), 0.7 * nrow(customer_data))
train_data <- customer_data[train_indices, ]
test_data <- customer_data[-train_indices, ]
classification_tree <- rpart(
customer_segment ~ purchase_frequency + total_quantity + avg_discount + preferred_payment + preferred_category,
data = train_data,
method = "class"
)
summary(classification_tree)
fancyRpartPlot(classification_tree)
predictions <- predict(classification_tree, test_data, type = "class")
test_data$predicted_segment <- predictions
confusion_matrix <- table(Actual = test_data$customer_segment, Predicted = test_data$predicted_segment)
print(confusion_matrix)
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
cat("Accuracy:", accuracy, "\n")
predicted_probs <- predict(classification_tree, test_data, type = "prob")
actual <- ifelse(test_data$customer_segment == "High", 1, 0)
predicted <- predicted_probs[, "High"]
thresholds <- seq(0, 1, by = 0.01)
tpr <- c()
fpr <- c()
for (threshold in thresholds) {
predicted_class <- ifelse(predicted >= threshold, 1, 0)
tp <- sum(predicted_class == 1 & actual == 1)
fp <- sum(predicted_class == 1 & actual == 0)
fn <- sum(predicted_class == 0 & actual == 1)
tn <- sum(predicted_class == 0 & actual == 0)
tpr <- c(tpr, tp / (tp + fn))
fpr <- c(fpr, fp / (fp + tn))
}
plot(fpr, tpr, type = "l", col = "blue", lwd = 2, xlab = "False Positive Rate", ylab = "True Positive Rate",
main = "ROC Curve")
abline(a = 0, b = 1, col = "red", lty = 2)
sortedindices = order(fpr)
fpr = fpr[sortedindices]
tpr = tpr[sortedindices]
auc = sum((fpr[-1] - fpr[-length(fpr)]) * (tpr[-1] + tpr[-length(tpr)]) / 2)
cat("AUC:",auc, "\n")
logistic_data <- cleaned_data %>%
mutate(
SalesChannel = ifelse(SalesChannel == "Online", 1, 0)
) %>%
select(
SalesChannel, CustomerID, Quantity, UnitPrice, Discount, OrderPriority, Country, PaymentMethod
)
set.seed(123)
train_indices <- sample(1:nrow(logistic_data), 0.7 * nrow(logistic_data))
train_data <- logistic_data[train_indices, ]
test_data <- logistic_data[-train_indices, ]
logistic_model <- glm(
SalesChannel ~ Quantity + UnitPrice + Discount + OrderPriority + Country + PaymentMethod,
data = train_data,
family = "binomial"
)
summary(logistic_model)
predicted_probabilities <- predict(logistic_model, test_data, type = "response")
test_data$predicted_channel <- ifelse(predicted_probabilities > 0.5, 1, 0)
confusion_matrix <- table(Actual = test_data$SalesChannel, Predicted = test_data$predicted_channel)
print(confusion_matrix)
performance <- confusionMatrix(factor(test_data$predicted_channel), factor(test_data$SalesChannel))
accuracy <- performance$overall["Accuracy"]
print(accuracy)
predicted_probs = predict(logistic_model, test_data, type = "response")
roc_curve= roc(test_data$SalesChannel, predicted_probabilities)
plot(roc_curve, col = "blue", lwd = 2, main = "ROC Curve")
abline(a = 0, b = 1, col = "red", lty = 2)
auc_value = auc(roc_curve)
cat("AUC:", auc_value, "\n")
# Select only numerical columns
numeric_columns <- logistic_data %>%
select(Quantity, UnitPrice, Discount, SalesChannel)
# Compute the correlation matrix
correlation_matrix <- cor(numeric_columns)
# Plot the correlation matrix
corrplot(correlation_matrix, method = "circle", type = "upper",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
col = colorRampPalette(c("blue", "white", "red"))(200))
```{r}
auc_value = auc(roc_curve)
cat("AUC:", auc_value, "\n")
# Extract feature importance from the model
feature_importance <- classification_tree$variable.importance
# Sort feature importance in descending order
sorted_importance <- sort(feature_importance, decreasing = TRUE)
# Create a data frame for plotting
importance_df <- data.frame(
Feature = names(sorted_importance),
Importance = sorted_importance
)
View(importance_df)
# Load ggplot2 library
library(ggplot2)
# Create the feature importance plot
ggplot(importance_df, aes(x = reorder(Feature, Importance), y = Importance)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +
labs(
title = "Feature Importance in Classification Tree",
x = "Features",
y = "Importance"
) +
theme_minimal()
confusion_matrix <- table(Actual = test_data$customer_segment, Predicted = test_data$predicted_segment)
print(confusion_matrix)
predictions <- predict(classification_tree, test_data, type = "class")
set.seed(123)
train_indices <- sample(1:nrow(customer_data), 0.7 * nrow(customer_data))
train_data <- customer_data[train_indices, ]
test_data <- customer_data[-train_indices, ]
classification_tree <- rpart(
customer_segment ~ purchase_frequency + total_quantity + avg_discount + preferred_payment + preferred_category,
data = train_data,
method = "class"
)
summary(classification_tree)
predictions <- predict(classification_tree, test_data, type = "class")
test_data$predicted_segment <- predictions
confusion_matrix <- table(Actual = test_data$customer_segment, Predicted = test_data$predicted_segment)
print(confusion_matrix)
# Extract feature importance from the model
feature_importance <- classification_tree$variable.importance
# Sort feature importance in descending order
sorted_importance <- sort(feature_importance, decreasing = TRUE)
# Create a data frame for plotting
importance_df <- data.frame(
Feature = names(sorted_importance),
Importance = sorted_importance
)
{r}
# Load ggplot2 library
library(ggplot2)
# Create the feature importance plot
ggplot(importance_df, aes(x = reorder(Feature, Importance), y = Importance)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +
labs(
title = "Feature Importance in Classification Tree",
x = "Features",
y = "Importance"
) +
theme_minimal()
# Select only numerical columns
numeric_columns <- logistic_data %>%
select(Quantity, UnitPrice, Discount, SalesChannel)
# Compute the correlation matrix
correlation_matrix <- cor(numeric_columns)
{r}
# Select only numerical columns
numeric_columns <- logistic_data %>%
select(Quantity, UnitPrice, Discount, SalesChannel)
# Compute the correlation matrix
correlation_matrix <- cor(numeric_columns)
# Plot the correlation matrix
corrplot(correlation_matrix, method = "circle", type = "upper",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
col = colorRampPalette(c("blue", "white", "red"))(200))
# Select only numerical columns
numeric_columns <- logistic_data %>%
select(Quantity, UnitPrice, Discount, SalesChannel)
# Compute the correlation matrix
correlation_matrix <- cor(numeric_columns)
# Plot the correlation matrix
corrplot(correlation_matrix, method = "square", type = "upper",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
col = colorRampPalette(c("blue", "white", "purple"))(200))
cor_matrix <- cor(customer_data %>%
select(purchase_frequency, total_quantity, avg_discount, preferred_payment, preferred_category),
use = "complete.obs")
corrplot(
cor_matrix,
method = "color",
type = "upper",
addCoef.col = "black",
tl.col = "black",
col = colorRampPalette(c("red", "white", "purple"))(200),
mar = c(0, 0, 1, 0))
fancyRpartPlot(classification_tree)
predictions <- predict(classification_tree, test_data, type = "class")
test_data$predicted_segment <- predictions
confusion_matrix <- confusionMatrix(
data = as.factor(test_data$predicted_segment),
reference = as.factor(test_data$customer_segment))
print(confusion_matrix)
cat("Accuracy:", confusion_matrix$overall["Accuracy"], "\n")
predicted_probs <- predict(classification_tree, test_data, type = "prob")
actual <- ifelse(test_data$customer_segment == "High", 1, 0)
predicted <- predicted_probs[, "High"]
thresholds <- seq(0, 1, by = 0.01)
tpr <- c()
fpr <- c()
for (threshold in thresholds) {
predicted_class <- ifelse(predicted >= threshold, 1, 0)
tp <- sum(predicted_class == 1 & actual == 1)
fp <- sum(predicted_class == 1 & actual == 0)
fn <- sum(predicted_class == 0 & actual == 1)
tn <- sum(predicted_class == 0 & actual == 0)
tpr <- c(tpr, tp / (tp + fn))
fpr <- c(fpr, fp / (fp + tn))
}
plot(fpr, tpr, type = "l", col = "blue", lwd = 2, xlab = "False Positive Rate", ylab = "True Positive Rate",
main = "ROC Curve")
abline(a = 0, b = 1, col = "red", lty = 2)
predicted_probabilities <- predict(logistic_model, newdata = test_data, type = "response")
logistic_data <- cleaned_data %>%
mutate(
SalesChannel = ifelse(SalesChannel == "Online", 1, 0)
) %>%
select(
SalesChannel, CustomerID, Quantity, UnitPrice, Discount, OrderPriority, PaymentMethod)
set.seed(123)
train_indices <- sample(1:nrow(logistic_data), 0.7 * nrow(logistic_data))
train_data <- logistic_data[train_indices, ]
test_data <- logistic_data[-train_indices, ]
logistic_model <- glm(
SalesChannel ~ Quantity + UnitPrice + Discount + OrderPriority + PaymentMethod,
data = train_data,
family = "binomial"
)
summary(logistic_model)
logistic_model$coefficients
predicted_probabilities <- predict(logistic_model, newdata = test_data, type = "response")
predicted_class <- ifelse(predicted_probabilities > 0.5, 1, 0)
test_data$predicted_sales_channel <- predicted_class
predicted_probabilities <- predict(logistic_model, newdata = test_data, type = "response")
predicted_class <- ifelse(predicted_probabilities > 0.5, 1, 0)
test_data$predicted_sales_channel <- predicted_class
#Correlation Plot
# Select only numerical columns
numeric_columns <- logistic_data %>%
select(Quantity, UnitPrice, Discount, SalesChannel)
# Compute the correlation matrix
correlation_matrix <- cor(numeric_columns)
# Plot the correlation matrix
corrplot(correlation_matrix, method = "square", type = "upper",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
col = colorRampPalette(c("blue", "white", "purple"))(200))
logistic_data <- cleaned_data %>%
mutate(
SalesChannel = ifelse(SalesChannel == "Online", 1, 0)
) %>%
select(
SalesChannel, CustomerID, Quantity, UnitPrice, Discount, OrderPriority, PaymentMethod)
set.seed(123)
train_indices <- sample(1:nrow(logistic_data), 0.7 * nrow(logistic_data))
train_data <- logistic_data[train_indices, ]
test_data <- logistic_data[-train_indices, ]
logistic_model <- glm(
SalesChannel ~ Quantity + UnitPrice + Discount + OrderPriority + PaymentMethod,
data = train_data,
family = "binomial"
)
summary(logistic_model)
logistic_model$coefficients
predicted_probabilities <- predict(logistic_model, newdata = test_data, type = "response")
predicted_class <- ifelse(predicted_probabilities > 0.5, 1, 0)
test_data$predicted_sales_channel <- predicted_class
library(ggplot2)
# Add predicted probabilities to test data
test_data$predicted_probabilities <- predicted_probabilities
# Scatter plot of actual vs predicted probabilities
ggplot(test_data, aes(x = SalesChannel, y = predicted_probabilities)) +
geom_jitter(alpha = 0.6, color = "blue", width = 0.2) +
labs(title = "Predicted Probabilities vs Actual Sales Channel",
x = "Actual Sales Channel (0 = In-store, 1 = Online)",
y = "Predicted Probabilities") +
theme_minimal()
ggplot(test_data, aes(x = as.factor(SalesChannel), y = predicted_probabilities)) +
geom_boxplot(fill = "lightblue") +
labs(title = "Predicted Probabilities by Actual Sales Channel",
x = "Actual Sales Channel (0 = In-store, 1 = Online)",
y = "Predicted Probabilities") +
theme_minimal()
#Correlation Plot
# Select only numerical columns
numeric_columns <- logistic_data %>%
select(Quantity, UnitPrice, Discount, SalesChannel)
# Compute the correlation matrix
correlation_matrix <- cor(numeric_columns)
# Plot the correlation matrix
corrplot(correlation_matrix, method = "square", type = "upper",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
col = colorRampPalette(c("blue", "white", "purple"))(200))
confusion_matrix2 <- confusionMatrix(
data = as.factor(test_data$predicted_sales_channel),
reference = as.factor(test_data$SalesChannel))
print(confusion_matrix2)
predicted_probs = predict(logistic_model, test_data, type = "response")
roc_curve= roc(test_data$SalesChannel, predicted_probabilities)
plot(roc_curve, col = "blue", lwd = 2, main = "ROC Curve")
abline(a = 0, b = 1, col = "red", lty = 2)
auc_value = auc(roc_curve)
cat("AUC:", auc_value, "\n")
# Extract feature importance from the model
feature_importance <- classification_tree$variable.importance
# Sort feature importance in descending order
sorted_importance <- sort(feature_importance, decreasing = TRUE)
# Create a data frame for plotting
importance_df <- data.frame(
Feature = names(sorted_importance),
Importance = sorted_importance
)
# Load ggplot2 library
library(ggplot2)
# Create the feature importance plot
ggplot(importance_df, aes(x = reorder(Feature, Importance), y = Importance)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +
labs(
title = "Feature Importance in Classification Tree",
x = "Features",
y = "Importance"
) +
theme_minimal()
# Extract feature importance from the model
feature_importance <- classification_tree$variable.importance
# Sort feature importance in descending order
sorted_importance <- sort(feature_importance, decreasing = TRUE)
# Create a data frame for plotting
importance_df <- data.frame(
Feature = names(sorted_importance),
Importance = sorted_importance
)
# Load ggplot2 library
library(ggplot2)
# Create the feature importance plot
ggplot(importance_df, aes(x = reorder(Feature, Importance), y = Importance)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +
labs(
title = "Feature Importance in Classification Tree",
x = "Features",
y = "Importance"
) +
theme_minimal()
# Extract coefficients from the model
coefficients <- summary(logistic_model)$coefficients
# Calculate absolute values of coefficients for feature importance
feature_importance <- abs(coefficients[, "Estimate"])
# Exclude the intercept
feature_importance <- feature_importance[-1]
# Create a data frame for visualization
importance_df <- data.frame(
Feature = names(feature_importance),
Importance = feature_importance
)
# Order by importance
importance_df <- importance_df[order(importance_df$Importance, decreasing = TRUE), ]
# Plot the feature importance
library(ggplot2)
ggplot(importance_df, aes(x = reorder(Feature, Importance), y = Importance)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +
labs(
title = "Feature Importance - Logistic Regression",
x = "Features",
y = "Absolute Coefficient Value"
) +
theme_minimal()
confusion_matrix2 <- confusionMatrix(
data = as.factor(test_data$predicted_sales_channel),
reference = as.factor(test_data$SalesChannel))
print(confusion_matrix2)
#Correlation Plot
# Select only numerical columns
numeric_columns <- logistic_data %>%
select(Quantity, UnitPrice, Discount, SalesChannel)
# Compute the correlation matrix
correlation_matrix <- cor(numeric_columns)
# Plot the correlation matrix
corrplot(correlation_matrix, method = "square", type = "upper",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
col = colorRampPalette(c("blue", "white", "purple"))(200))
